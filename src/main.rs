use anyhow::{anyhow, Result};
use clap::Parser;
use std::fmt::Debug;
use std::fs::File;
use std::io::{stdout, IsTerminal, Write};
use std::path::PathBuf;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Force output file, disregarding existing file.
    #[arg(short, long)]
    force: bool,

    /// Specifies a master/main target that relies on all other targets.
    #[arg(short, long, value_name = "TARGET")]
    master_target: Option<String>,

    /// Specify a separate rule for the master target, if specified.
    #[arg(long, value_name = "TAG")]
    master_rule: Option<String>,

    /// Ignore terminal input when reading from stdin.
    #[arg(short, long)]
    no_tty: bool,

    /// Specifies the path for the output ninja file.
    #[arg(short, long, value_name = "PATH")]
    output: Option<PathBuf>,

    /// Specifies the rule name preceding each source.
    #[arg(short, long, value_name = "NAME", default_value = "cc")]
    rule: String,

    /// Source file paths.
    #[arg()]
    sources: Vec<String>,

    /// Show some undefined information during processing.
    #[arg(short, long)]
    verbose: bool,
}

fn format_target(path: &str) -> Result<String> {
    let target = String::from(
        PathBuf::from(path)
            .file_stem()
            .ok_or(anyhow!("path should include a file name"))?
            .to_str() // TODO replace with display when out of nightly
            .ok_or(anyhow!("filename should be UTF-8"))?,
    );
    return Ok(target);
}

fn format_line(target: &str, rule: &str, path: &str) -> String {
    return format!("build {}: {} {}", target, rule, path);
}

fn main() -> Result<()> {
    let args: Args = Args::parse();

    // idk, show args
    if args.verbose {
        println!("{:?}", args);
    }

    // create a writer to either the specified output file, or stdout if none specified.
    let mut writer: Box<dyn Write> = match args.output {
        Some(ref path) => match args.force {
            true => Box::new(File::create(path)?),
            false => Box::new(File::create_new(path)?),
        },
        None => Box::new(stdout()),
    };

    // write banner if writing to a file
    if args.output.is_some() {
        writeln!(writer, "# generated by sensei")?;
    }

    // create vec to capture build targets
    let mut targets: Vec<String> = Vec::new();

    // process from command line
    for path in &args.sources {
        let target = format_target(&path)?;
        let line = format_line(&target, &args.rule, &path);
        writeln!(writer, "{line}")?;
        targets.push(target);
    }

    // process from stdin
    let stdin = std::io::stdin();
    if !(stdin.is_terminal() && args.no_tty) {
        if !stdin.is_terminal() || (stdin.is_terminal() && (targets.len() == 0)) {
            for input in stdin.lines() {
                let path = input?;
                let target = format_target(&path)?;
                let line = format_line(&target, &args.rule, &path);
                writeln!(writer, "{line}")?;
                targets.push(target);
            }
        }
    }

    // print message about target count
    if args.verbose {
        println!("Created {} targets.", targets.len());
    }

    // write master rule if specified
    match args.master_target {
        Some(mtarget) => {
            let mrule = match args.master_rule {
                Some(rule) => rule,
                None => args.rule,
            };
            let line = format_line(&mtarget, &mrule, &targets.join(" "));
            writeln!(writer, "{line}")?;
        }
        None => (),
    }

    return Ok(());
}
